package movieapp.persistance;



import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;

import javax.persistence.EntityManager;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.NullSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.dao.DataIntegrityViolationException;

import movieapp.entity.Movie;

@DataJpaTest
class MovieRepositoryTest {

	@Autowired
	private MovieRepository movieRepository;
	
	@Autowired
	private EntityManager entityManager;
	
	@ParameterizedTest
	@ValueSource(strings = {
			"Z", 
			"Blade Runner", 
			"Night of the Day of the Dawn of the Son of the Bride of the Return of the Revenge of the Terror of the Attack of the Evil Mutant Hellbound Flesh Eating Crawling Alien Zombified Subhumanoid Living Dead, Part 5"})
	void testSaveTitle(String title) {
		// given
		int year = 1982;
		int duration = 173;
		// when + then
		saveAssertMovie(title, year, duration);
	}
	
	@ParameterizedTest
	@ValueSource(ints = {
			1, 
			170, 
			Integer.MAX_VALUE})
	@NullSource
	void testMovieWithDuration(Integer duration) {
		String title = "test " + duration + "mn";
		int year = 2020;
		saveAssertMovie(title, year, duration);
		
	}
	
	@Test
	void testSaveTitleEmptyNOK() {
		String title = null;
		int year = 1982;
		int duration = 173;
		assertThrows(DataIntegrityViolationException.class, 
				() -> saveAssertMovie(title, year, duration));
	}
	
	@Test
	void testFindByTitle() {
		String title = "un titre multiple";
		var movies = List.of(
			new Movie(title, 2020),
			new Movie(title, 2021),
			new Movie(title, 2022),
			new Movie("autre titre", 2020)
		);
		movies.forEach(entityManager::persist);
		entityManager.flush();
		var moviesFound = movieRepository.findByTitle(title);
		assertEquals(3, moviesFound.size());
		assertAll(moviesFound.stream().map(
				m -> () -> assertEquals(title, m.getTitle() ))
				);
	}
	
	
	@Test
	void testFindByTitleContainingIgnoreCase() {
		final String str = "Man";
		var movies = List.of(
			new Movie("Man of the year", 2020),
			new Movie("Invisible man", 2021),
			new Movie("Wonder Woman", 2022),
			new Movie("Unforgettable", 2020)
		);
		movies.forEach(entityManager::persist);
		entityManager.flush();
		var moviesFound = movieRepository.findByTitleContainingIgnoreCase(str);
		assertEquals(3, moviesFound.size());
		assertAll(moviesFound.stream().map(
				m -> () -> assertTrue(m.getTitle().toLowerCase().contains(str.toLowerCase()), m.getTitle().toLowerCase()))); 
					// assertTrue(m.getTitle().toLowerCase().contains(str)
						//, m.getTitle().toLowerCase()));
	}
	
	private void saveAssertMovie(String title, Integer year, Integer duration) {
		Movie movie = new Movie(title, year, duration);
		// when
		movieRepository.save(movie);
		// then
		var idMovie = movie.getId();
		assertNotNull(idMovie, "id generated by database");
	}
	
	@Test
	void testFindByYearGreaterThanEqual() {
		final int down = 2021;
		var movies = List.of(
			new Movie("Man of the year", 2020),
			new Movie("Invisible man", 2021),
			new Movie("Wonder Woman", 2022),
			new Movie("Unforgettable", 2020)
		);
		movies.forEach(entityManager::persist);
		entityManager.flush();
		var moviesFound = movieRepository.findByYearGreaterThanEqual(down);
		assertEquals(2, moviesFound.size());
		assertAll(moviesFound.stream().map(
				m -> () -> assertTrue(m.getYear() >= down, "year should be >= " + down)
				)
				); 
	}
	
	@Test
	void testfindByYearBetween() {
		final int down = 2020;
		final int up = 2021;
		var movies = List.of(
			new Movie("Man of the year", 2019),
			new Movie("Invisible man", 2021),
			new Movie("Wonder Woman", 2022),
			new Movie("Unforgettable", 2020)
		);
		movies.forEach(entityManager::persist);
		entityManager.flush();
		var moviesFound = movieRepository.findByYearBetween(down, up);
		assertEquals(2, moviesFound.size());
		assertAll(moviesFound.stream().map(
				m -> () -> assertTrue(m.getYear() >= down && m.getYear() <= up, "year should be >= " + down)
				)
				); 
	}

	@Test
	void testFindByDurationNull() {
		var movies = List.of(
			new Movie("Man of the year", 2019),
			new Movie("Invisible man", 2021, 178),
			new Movie("Wonder Woman", 2022, null),
			new Movie("Unforgettable", 2020, 210)
		);
		movies.forEach(entityManager::persist);
		entityManager.flush();
		var moviesFound = movieRepository.findByDurationNull();
		assertEquals(2, moviesFound.size());
		assertAll(moviesFound.stream().map(
				m -> () -> assertTrue(m.getDuration() == null, "Duration null")
				)
				); 
	}
	
	@Test
	void testFindByTitleAndYear() {
		final String title="Invisible man";
		final int year = 1985;
		var movies = List.of(
			new Movie("Man of the year", 2019),
			new Movie("Invisible man", 2021, 178),
			new Movie("Invisible man", 1985, null),
			new Movie("Unforgettable", 2020, 210)
		);
		movies.forEach(entityManager::persist);
		entityManager.flush();
		var moviesFound = movieRepository.findByTitleIgnoreCaseAndYear(title, year);
		assertEquals(1, moviesFound.size());
		assertAll(moviesFound.stream().map(
				m -> () -> assertTrue(m.getTitle().toLowerCase().equals(title.toLowerCase()) && m.getYear() == year)
				)
				); 
	}
}